import _ from "lodash"
import { classLibrary } from "../game/classLibrary"
import { BRUSH_ID_PREFIX, defaultClass, defaultObjectInstance, defaultStage, EFFECT_CUTSCENE, initialTags, NON_LAYER_BRUSH_ID } from "../game/constants"
import { mergeDeep } from "./utils"
import { defaultTag, EFFECT_DESTROY, EFFECT_RECLASS, EFFECT_TELEPORT,  ON_INTERACT, playerTagId, PLAYER_CLASS, playgroundTagId, PLAYGROUND_LAYER_CANVAS_ID, TAG_CLASS, TAG_CUTSCENE, TAG_DIALOGUE, TAG_LIBRARY, ZONE_CLASS } from '../game/constants';
import { libraryClassAugment } from '../game/constants';

export function addDefaultsToGameModel(gameData, oldGameData) {
  if(oldGameData) {
    if(gameData.stages) {
      Object.keys(gameData.stages).forEach((stageId) => {
        const stage = gameData.stages[stageId]
        if(stage && oldGameData.stages[stageId]) {
          const objects = stage.objects 
          const oldObjects = oldGameData.stages[stageId].objects
          if(objects) Object.keys(objects).forEach((id) => {
            if(!oldObjects[id]) objects[id] = mergeDeep(_.cloneDeep(defaultObjectInstance), objects[id])
          })
        }
      })
    }

    if(gameData.classes) Object.keys(gameData.classes).forEach((id) => {
      if(!oldGameData.classes[id]) gameData.classes[id] = mergeDeep(_.cloneDeep(defaultClass), gameData.classes[id])
    })

    return 
  }

  if(gameData.classes) {
    Object.keys(gameData.classes).forEach((id) => {
      gameData.classes[id] = mergeDeep(_.cloneDeep(defaultClass), gameData.classes[id])
    })
  }

  if(gameData.stages) {
    Object.keys(gameData.stages).forEach((stageId) => {
      const stage = gameData.stages[stageId]
      gameData.stages[stageId] = mergeDeep(_.cloneDeep(defaultStage), gameData.stages[stageId])
      const objects = stage.objects 
      if(objects) Object.keys(objects).forEach((id) => {
        objects[id] = mergeDeep(_.cloneDeep(defaultObjectInstance), objects[id])
      })
    })
  }
}

export function addLibraryToGameModel(gameData) {
  classLibrary.forEach((libraryObjectClass) => {
    if(!gameData.classes[libraryObjectClass.classId]) {
      gameData.classes[libraryObjectClass.classId] = mergeDeep(_.cloneDeep(libraryObjectClass), _.cloneDeep(libraryClassAugment))
    } else {
      gameData.classes[libraryObjectClass.classId] = mergeDeep(_.cloneDeep(libraryObjectClass), _.cloneDeep(libraryClassAugment), gameData.classes[libraryObjectClass.classId])
    }
  })

  gameData.tags = {
    ..._.cloneDeep(initialTags),
    ...gameData.tags
  }
}

export function enrichGameModel(gameData) {
  if(!gameData.brushes) gameData.brushes = {}
  if(!gameData.tags) gameData.tags = {}

  Object.keys(gameData.cutscenes).forEach((cutsceneId) => {
    const cutscene = gameData.cutscenes[cutsceneId]
    gameData.effects[cutsceneId] = {
      effectId: cutsceneId,
      type: EFFECT_CUTSCENE,
      cutsceneId,
      isAutogenerated: true
    }

    gameData.tags[cutsceneId] = {
      ...defaultTag,
      isAutogenerated: true,
      tagId: cutscene,
      name: 'Interact to play "' + cutscene.name + '"',
      type: cutscene.inDialogueMenu ? TAG_DIALOGUE : TAG_CUTSCENE
    }

    gameData.events[cutsceneId] = {
      eventId: cutsceneId,
      type: ON_INTERACT,
      tagIdA: playerTagId,
      tagIdB: cutsceneId,
      isAutogenerated: true
    }

    gameData.relations[cutsceneId] = {
      relationId: cutsceneId,
      eventId: cutsceneId,
      effects: {
        [cutsceneId]: {
          effectId: cutsceneId
        }
      },
      effectIds: [cutsceneId],
      isAutogenerated: true
    }
  })

  Object.keys(gameData.classes).forEach((classId) => {
    const objectClass = gameData.classes[classId]

    objectClass.tags[classId] = {
      isAutogenerated: true
    }
    if(objectClass.type === PLAYER_CLASS) {
      objectClass.tags[playerTagId] = {
        isAutogenerated: true,
      }
    }

    const transformClassId = 'transform-'+classId
    gameData.effects[transformClassId] = {
      effectId: transformClassId,
      type: EFFECT_RECLASS,
      classId,
      isAutogenerated: true
    }

    if(objectClass.type === ZONE_CLASS) {
      const teleportClassId = 'teleport-'+classId
      gameData.effects[teleportClassId] = {
        effectId: teleportClassId,
        type: EFFECT_TELEPORT,
        zoneClassId: classId,
        isAutogenerated: true
      }
    }


    // if(objectClass.graphics.layerId === PLAYGROUND_LAYER_CANVAS_ID) {
    //   objectClass.tags[playgroundTagId] = {
    //     isAutogenerated: true
    //   }
    // }
    
    if(objectClass.graphics.textureId) {
      gameData.brushes[BRUSH_ID_PREFIX + objectClass.classId] = {
        layerCanvasId: NON_LAYER_BRUSH_ID,
        textureId: objectClass.graphics.textureId,
        tint: objectClass.graphics.tint
      }
    }

    gameData.tags[objectClass.classId] = {
      type: TAG_CLASS,
      isAutogenerated: true,
      textureId: objectClass.graphics.textureId,
      interfaceLocked: objectClass.interfaceLocked,
      color: objectClass.graphics.tint,
      tagId: objectClass.classId,
      isRemoved: objectClass.isRemoved,
      name: objectClass.name,
    }
  })
  
  Object.keys(gameData.tags).forEach((tagId) => {
    const tag = gameData.tags[tagId]

    if(tag.type === TAG_CLASS || tag.type === TAG_LIBRARY) {
      const destroyTagId = 'destroy-'+tagId
      gameData.effects[destroyTagId] = {
        effectId: destroyTagId,
        type: EFFECT_DESTROY,
        remoteEffectedTagIds: [tagId],
        isAutogenerated: true
      }
    }
  })

}

export function cleanGameModel(gameData) {
  Object.keys(gameData.stages).forEach((key) => {
    const stage = gameData.stages[key]
    if (gameData.stages[key] === null || gameData.stages[key] === undefined) {
      console.log('deleting stage', key)
      delete gameData.stages[key];
    }

    // the default stage doesnt start with objects because its virtual so gotta check
    if(stage.objects) Object.keys(stage.objects).forEach(key => {
      if (stage.objects[key] === null || stage.objects[key] === undefined) {
        console.log('deleting object', key)
        delete stage.objects[key];
      }
    });
  })

  Object.keys(gameData.cutscenes).forEach(key => {
    if (gameData.cutscenes[key] === null || gameData.cutscenes[key] === undefined) {
      console.log('deleting cutscene', key)
      delete gameData.cutscenes[key];
    }
  });

  Object.keys(gameData.classes).forEach(key => {
    if (gameData.classes[key] === null || gameData.classes[key] === undefined) {
      console.log('deleting class', key)
      delete gameData.classes[key];
      return
    }
  });

  Object.keys(gameData.relations).forEach(key => {
    if (gameData.relations[key] === null || gameData.relations[key] === undefined) {
      console.log('deleting relation', key)
      delete gameData.relations[key];
    }
  });

  Object.keys(gameData.collisions).forEach(key => {
    if (gameData.collisions[key] === null || gameData.collisions[key] === undefined) {
      console.log('deleting collision', key)
      delete gameData.collisions[key];
    }
  });


  Object.keys(gameData.effects).forEach(key => {
    if (gameData.effects[key] === null || gameData.effects[key] === undefined) {
      console.log('deleting effect', key)
      delete gameData.effects[key];
    }
  });

  Object.keys(gameData.events).forEach(key => {
    if (gameData.events[key] === null || gameData.events[key] === undefined) {
      console.log('deleting event', key)
      delete gameData.events[key];
    }
  });
}
