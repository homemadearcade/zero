import _ from "lodash"
import { classLibrary } from "../game/classLibrary"
import { defaultEntity, defaultEntityInstance, defaultPowerupEntity, defaultStage, defaultRelationTag, effectBehaviorInterfaces, EFFECT_CUTSCENE, EFFECT_DESTROY, EFFECT_SPAWN, EFFECT_TELEPORT, EFFECT_TRANSFORM, initialTags, libraryEntityAugment, ON_INTERACT, playerRelationTagId, RELATION_TAG_ENTITY, RELATION_TAG_CUTSCENE, RELATION_TAG_DIALOGUE, RELATION_TAG_LIBRARY, RELATION_TAG_TELEPORT, RELATION_TAG_TRANSFORM } from "../game/constants"
import { BRUSH_ID_PREFIX, DATA_SOURCE_AUTOGENERATED, ON_TOUCH_START, POWERUP_CLASS } from "../game/constants/core"
import { NON_LAYER_BRUSH_ID } from "../game/constants/core"
import { initialStageZoneEntityId } from "../game/constants/core"
import { PLAYER_CLASS } from "../game/constants/core"
import { mergeDeep } from "../utils/utils"
import { getPlayerPowerupEntityId } from "./utils"

export function addAutogeneratedEntityModels(gameData) {
  if(gameData.entityModels) {
    Object.keys(gameData.entityModels).forEach((entityModelId) => {
      const entityModel = gameData.entityModels[entityModelId]
      if(entityModel.entityInterfaceId === PLAYER_CLASS) {
        const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
        const powerUpEntity  = {
          dataSource: DATA_SOURCE_AUTOGENERATED,
          name: 'Touch Transform - ' + entityModel.name,
          relationTags: {
            [playerPowerUpEntityId]: {
              wasAutoapplied: true
            }
          },
          autogeneration: {
            automaticEntityTag: false,
          },
          entityInterfaceId: POWERUP_CLASS,
          entityModelId: playerPowerUpEntityId,
          graphics: {
            textureId: entityModel.graphics.textureId,
            textureTint: entityModel.graphics.textureTint
          }
        }

        if(gameData.entityModels[playerPowerUpEntityId]) {
          gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultPowerupEntity), powerUpEntity, gameData.entityModels[playerPowerUpEntityId])
        } else {
          gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultPowerupEntity), powerUpEntity)
        }
      }
    })
  }
}

export function addDefaultsToGameModel(gameData, oldGameData) {
  if(oldGameData) {
    if(gameData.stages) {
      Object.keys(gameData.stages).forEach((stageId) => {
        const stage = gameData.stages[stageId]
        if(stage && oldGameData.stages[stageId]) {
          const entityInstances = stage.entityInstances 
          const oldObjects = oldGameData.stages[stageId].entityInstances
          if(entityInstances) Object.keys(entityInstances).forEach((id) => {
            if(!oldObjects[id]) entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
          })
        }
      })
    }

    if(gameData.entityModels) Object.keys(gameData.entityModels).forEach((id) => {
      if(!oldGameData.entityModels[id]) gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity), gameData.entityModels[id])
    })

    return 
  }

  if(gameData.entityModels) {
    Object.keys(gameData.entityModels).forEach((id) => {
      if(gameData.entityModels[id].dataSource === DATA_SOURCE_AUTOGENERATED) {
        console.log('skipping')
        return 
      }
      gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity),  gameData.entityModels[id])
    })
  }

  if(gameData.stages) {
    Object.keys(gameData.stages).forEach((stageId) => {
      const stage = gameData.stages[stageId]
      gameData.stages[stageId] = mergeDeep(_.cloneDeep(defaultStage), gameData.stages[stageId])
      const entityInstances = stage.entityInstances 
      if(entityInstances) Object.keys(entityInstances).forEach((id) => {
        entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
      })
    })
  }
}

export function addLibraryToGameModel(gameData) {
  classLibrary.forEach((libraryEntityModel) => {
    if(!gameData.entityModels[libraryEntityModel.entityModelId]) {
      gameData.entityModels[libraryEntityModel.entityModelId] = mergeDeep(_.cloneDeep(libraryEntityModel), _.cloneDeep(libraryEntityAugment))
    } else {
      gameData.entityModels[libraryEntityModel.entityModelId] = mergeDeep(_.cloneDeep(libraryEntityModel), _.cloneDeep(libraryEntityAugment), gameData.entityModels[libraryEntityModel.entityModelId])
    }
  })

  gameData.relationTags = {
    ..._.cloneDeep(initialTags),
    ...gameData.relationTags
  }
}

export function enrichGameModel(gameData) {
  if(!gameData.brushes) gameData.brushes = {}
  if(!gameData.relationTags) gameData.relationTags = {}

  Object.keys(effectBehaviorInterfaces).forEach((effectBehavior) => {
    const effectBehaviorInterface = effectBehaviorInterfaces[effectBehavior]
    if(effectBehaviorInterface.isStandalone) {
      gameData.effects[effectBehavior] = {
        effectId: effectBehavior,
        effectBehavior: effectBehavior,
        dataSource: DATA_SOURCE_AUTOGENERATED,
        customSelectorCategory: '_General'
      }
    }
  })

  Object.keys(gameData.cutscenes).forEach((cutsceneId) => {
    const cutscene = gameData.cutscenes[cutsceneId]
    
    gameData.effects[cutsceneId] = {
      effectId: cutsceneId,
      effectBehavior: EFFECT_CUTSCENE,
      cutsceneId,
      dataSource: DATA_SOURCE_AUTOGENERATED
    }

    gameData.relationTags[cutsceneId] = {
      dataSource: DATA_SOURCE_AUTOGENERATED,
      relationTagId: cutsceneId,
      name: 'Interact to play "' + cutscene.name + '"',
      relationTagInterfaceId: cutscene.inDialogueMenu ? RELATION_TAG_DIALOGUE : RELATION_TAG_CUTSCENE
    }

    gameData.events[cutsceneId] = {
      eventId: cutsceneId,
      eventType: ON_INTERACT,
      relationTagIdA: playerRelationTagId,
      relationTagIdB: cutsceneId,
      dataSource: DATA_SOURCE_AUTOGENERATED
    }

    gameData.relations[cutsceneId] = {
      relationId: cutsceneId,
      eventId: cutsceneId,
      effects: {
        [cutsceneId]: {
          effectId: cutsceneId
        }
      },
      effectIds: [cutsceneId],
      dataSource: DATA_SOURCE_AUTOGENERATED
    }
  })

  Object.keys(gameData.entityModels).forEach((entityModelId) => {
    const entityModel = gameData.entityModels[entityModelId]

    entityModel.relationTags[entityModelId] = {
      wasAutoapplied: true
    }
    if(entityModel.entityInterfaceId === PLAYER_CLASS) {
      entityModel.relationTags[playerRelationTagId] = {
        wasAutoapplied: true,
      }
    }
   
    const transformIntoEffect = entityModel.autogeneration.transformIntoEffect
    if(transformIntoEffect) {
      const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
      
      gameData.effects[playerPowerUpEntityId] = {
        effectId: playerPowerUpEntityId,
        effectBehavior: EFFECT_TRANSFORM,
        entityModelId,
        dataSource: DATA_SOURCE_AUTOGENERATED
      }

      const playerTransformIntoRelationTag = entityModel.autogeneration.playerTransformIntoRelationTag
      if(playerTransformIntoRelationTag) {
        gameData.events[playerPowerUpEntityId] = {
          eventId: playerPowerUpEntityId,
          eventType: ON_TOUCH_START,
          relationTagIdA: playerRelationTagId,
          relationTagIdB: playerPowerUpEntityId,
          dataSource: DATA_SOURCE_AUTOGENERATED
        }

        gameData.relations[playerPowerUpEntityId] = {
          relationId: playerPowerUpEntityId,
          eventId: playerPowerUpEntityId,
          effects: {
            [playerPowerUpEntityId]: {
              effectTagA: true,
              effectId: playerPowerUpEntityId
            }
          },
          effectIds: [playerPowerUpEntityId],
          dataSource: DATA_SOURCE_AUTOGENERATED,
        }

        gameData.relationTags[playerPowerUpEntityId] = {
          dataSource: DATA_SOURCE_AUTOGENERATED,
          relationTagId: playerPowerUpEntityId,
          name: 'Touch to transform Player into ' + entityModel.name + '',
          relationTagInterfaceId: RELATION_TAG_TRANSFORM,
          editorInterface: {
            requiresUnlocking: true
          }
        }
      }
    }

    const teleportToEffect = entityModel.autogeneration.teleportToEffect
    if(teleportToEffect) {
     
      const teleportEntityId = 'teleport-'+entityModelId
      gameData.effects[teleportEntityId] = {
        effectId: teleportEntityId,
        effectBehavior: EFFECT_TELEPORT,
        zoneEntityModelId: entityModelId,
        dataSource: DATA_SOURCE_AUTOGENERATED
      }

      const playerTeleportToRelationTag = entityModel.autogeneration.playerTeleportToRelationTag
      if(playerTeleportToRelationTag) {
        gameData.events[teleportEntityId] = {
          eventId: teleportEntityId,
          eventType: ON_INTERACT,
          relationTagIdA: playerRelationTagId,
          relationTagIdB: teleportEntityId,
          dataSource: DATA_SOURCE_AUTOGENERATED
        }

        gameData.relations[teleportEntityId] = {
          relationId: teleportEntityId,
          eventId: teleportEntityId,
          effects: {
            [teleportEntityId]: {
              effectTagA: true,
              effectId: teleportEntityId
            }
          },
          effectIds: [teleportEntityId],
          dataSource: DATA_SOURCE_AUTOGENERATED
        }

        gameData.relationTags[teleportEntityId] = {
          dataSource: DATA_SOURCE_AUTOGENERATED,
          relationTagId: teleportEntityId,
          name: 'Interact to teleport Player to ' + entityModel.name + '',
          relationTagInterfaceId: RELATION_TAG_TELEPORT,
          editorInterface: {
            requiresUnlocking: true
          }
        }
      }
    }

    const spawnOntoStageEffect = entityModel.autogeneration.spawnOntoStageEffect
    if(spawnOntoStageEffect) {
      const spawnEntityModelId = 'spawn-'+entityModelId
      gameData.effects[spawnEntityModelId] = {
        effectId: spawnEntityModelId,
        effectBehavior: EFFECT_SPAWN,
        zoneEntityModelId: initialStageZoneEntityId,
        spawnEntityModelId: entityModelId,
        dataSource: DATA_SOURCE_AUTOGENERATED,
      }
    }

    if(entityModel.graphics.textureId) {
      gameData.brushes[BRUSH_ID_PREFIX + entityModel.entityModelId] = {
        layerId: NON_LAYER_BRUSH_ID,
        textureId: entityModel.graphics.textureId,
        textureTint: entityModel.graphics.textureTint,
        dataSource: DATA_SOURCE_AUTOGENERATED,
      }
    }

    if(entityModel.autogeneration.automaticEntityTag) {
      gameData.relationTags[entityModel.entityModelId] = {
        relationTagInterfaceId: RELATION_TAG_ENTITY,
        dataSource: DATA_SOURCE_AUTOGENERATED,
        textureId: entityModel.graphics.textureId,
        editorInterface: {
          requiresUnlocking: entityModel.editorInterface.requiresUnlocking,
        },
        entityInterfaceId: entityModel.entityInterfaceId,
        textureTint: entityModel.graphics.textureTint,
        relationTagId: entityModel.entityModelId,
        isRemoved: entityModel.isRemoved,
        name: entityModel.name,
      }
    }
  })
  
  Object.keys(gameData.relationTags).forEach((relationTagId) => {
    const relationTag = gameData.relationTags[relationTagId]
    const relationTagEntity  = gameData.entityModels[relationTagId]

    if(relationTag.relationTagInterfaceId === RELATION_TAG_ENTITY || relationTag.relationTagInterfaceId === RELATION_TAG_LIBRARY) {
      if(relationTagEntity?.destroyAllEffect) {
        const destroyRelationTagId = 'destroy-'+relationTagId
        gameData.effects[destroyRelationTagId] = {
          effectId: destroyRelationTagId,
          effectBehavior: EFFECT_DESTROY,
          remoteEffectedRelationTagIds: [relationTagId],
          dataSource: DATA_SOURCE_AUTOGENERATED
        }
      }
    }
  })

  Object.keys(gameData.relationTags).forEach((id) => {
    gameData.relationTags[id] = mergeDeep(_.cloneDeep(defaultRelationTag),  gameData.relationTags[id])
  })
}

export function cleanGameModel(gameData) {
  Object.keys(gameData.stages).forEach((key) => {
    const stage = gameData.stages[key]
    if (gameData.stages[key] === null || gameData.stages[key] === undefined) {
      console.log('deleting stage', key)
      delete gameData.stages[key];
    }

    // the default stage doesnt start with entityInstance because its virtual so gotta check
    if(stage.entityInstances) Object.keys(stage.entityInstances).forEach(key => {
      if (stage.entityInstances[key] === null || stage.entityInstances[key] === undefined) {
        console.log('deleting object', key)
        delete stage.entityInstances[key];
      }
    });
  })

  Object.keys(gameData.cutscenes).forEach(key => {
    if (gameData.cutscenes[key] === null || gameData.cutscenes[key] === undefined) {
      console.log('deleting cutscene', key)
      delete gameData.cutscenes[key];
    }
  });

  Object.keys(gameData.entityModels).forEach(key => {
    if (gameData.entityModels[key] === null || gameData.entityModels[key] === undefined) {
      console.log('deleting class', key)
      delete gameData.entityModels[key];
      return
    }
  });

  Object.keys(gameData.relations).forEach(key => {
    if (gameData.relations[key] === null || gameData.relations[key] === undefined) {
      console.log('deleting relation', key)
      delete gameData.relations[key];
    }
  });

  Object.keys(gameData.collisions).forEach(key => {
    if (gameData.collisions[key] === null || gameData.collisions[key] === undefined) {
      console.log('deleting collision', key)
      delete gameData.collisions[key];
    }
  });


  Object.keys(gameData.effects).forEach(key => {
    if (gameData.effects[key] === null || gameData.effects[key] === undefined) {
      console.log('deleting effect', key)
      delete gameData.effects[key];
    }
  });

  Object.keys(gameData.events).forEach(key => {
    if (gameData.events[key] === null || gameData.events[key] === undefined) {
      console.log('deleting event', key)
      delete gameData.events[key];
    }
  });

  
}
