import _ from "lodash"
import { DERIVED_AUTOGENERATION_IID, DERIVED_ENTITY_MODEL_IID, 
   RELATION_TAG_ENTITY_IID,
   RELATION_TAG_GENERAL_IID, RELATION_TAG_TELEPORT_IID, 
   RELATION_TAG_TRANSFORM_IID, PLAYER_ENTITY_IID, DERIVED_DEFAULT_SYSTEM_IID, 
   DERIVED_INTERFACE_ACTION_IID, 
   BASIC_ENTITY_IID,
   SINGLE_RELATION_TAG_EVENT_IID,
   PLAYER_AND_RELATION_TAG_EVENT_IID,
   TWO_RELATION_TAG_EVENT_IID,
   NO_RELATION_TAG_EFFECT_IID,
   SINGLE_RELATION_TAG_EFFECT_IID,
   TWO_RELATION_TAG_EFFECT_IID} from "../constants/interfaceIds"
import { effectEditInterfaces, EFFECT_CUTSCENE, EFFECT_DESTROY, EFFECT_SPAWN, EFFECT_TELEPORT, EFFECT_TRANSFORM,   
  ON_INTERACT, PLAYER_RELATION_TAG_ID, effectInterfaceDatas, 
   eventTypeInterfaces, eventShortNames, STAGE_ZONE_ENTITY_IVID, PLAYTHROUGH_START_CUTSCENE_IVID, END_GAME_CUTSCENE_IVID, 
 } from "../game/constants"
import { BRUSH_DID, CANVAS_IMAGE_LAYER_ID, EFFECT_DID, EFFECT_END_GAME, EFFECT_INTERFACE_ACTION, EFFECT_INTERFACE_UNLOCK, EFFECT_SWITCH_STAGE, EFFECT_TRANSFORM_TEMPORARY_START, NON_LAYER_COLOR_ID, ON_CUTSCENE_END, ON_DESTROY_ALL, ON_DESTROY_ONE, ON_PLAYTHROUGH, ON_TOUCH_START } from "../game/constants/core"
import { NON_LAYER_BRUSH_ID } from "../game/constants/core"
import { mergeDeep } from "../utils/utils"
import { getPlayerPowerupEntityId, getAutogeneratedTagDescription, getAutogeneratedTagName } from "./utils"
import { interfaceActionIdData } from "../constants/interfaceActionIdData"
import { interfaceActionGroupData, interfaceGroupData } from "../constants"
import { interfaceIdData } from "../constants/interfaceIdData"
import { generateCutsceneRelationTag } from "./cutsceneRelationTag"
import { 
    initialTags,
    defaultEntity,
    defaultEntityInstance,
    defaultRelationTag,
    defaultBasicEntity,
    defaultRelationship,
} from "../game/constants/initialGame"

export function generateActionEffects(gameModel) {
  if(!gameModel.effects) gameModel.effects = {}

  Object.keys(interfaceIdData).forEach((interfaceId) => {
    const interfaceData = interfaceIdData[interfaceId]
    const name = interfaceData.name || interfaceData.previewText

    const interfaceGroup = interfaceGroupData[interfaceData.interfaceGroupId]
    if(!name) return

    const effectId = EFFECT_DID + interfaceId
    gameModel.effects[effectId] = {
      effectId,
      effectBehavior: EFFECT_INTERFACE_UNLOCK,
      interfaceId: interfaceId,
      dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
      customSelectorCategory: 'Unlock ' + interfaceGroup.name + ' UI',
      title: 'Unlock ' + name,
      isReadOnly: true,
      isRemoved: interfaceData.isDefaultUnlocked
    }
  })

   Object.keys(interfaceActionIdData).forEach((interfaceActionId) => {
    const interfaceActionData = interfaceActionIdData[interfaceActionId]

    if(!interfaceActionData.arguments) {
      const effectId = EFFECT_DID + interfaceActionId
      const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
      if(!interfaceActionUIData) return console.error('no interface action ui data for ' + interfaceActionId)
      gameModel.effects[effectId] = {
        effectId,
        effectBehavior: EFFECT_INTERFACE_ACTION,
        interfaceActionId,
        dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
        customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
        title: interfaceActionData.title,
        subTitle: interfaceActionData.subTitle,
        onClick: interfaceActionData.onClick(),
        isActive: interfaceActionData.isActive,
        icon: interfaceActionData.icon || interfaceActionUIData.icon,
        subIcon: interfaceActionData.subIcon,
        isReadOnly: true
      }
    } else {
      interfaceActionData.arguments.forEach((arg1, arg2) => {
        if(arg1 && arg2) return console.error('we cannot do this yet')
        if(arg1 === 'entityModelId') {
          // create an action for each entity model and pass in the entity model into the getSubtitle method to get the name
          if(gameModel.entityModels) Object.keys(gameModel.entityModels).forEach((entityModelId) => {
            const effectId = EFFECT_DID + interfaceActionId + entityModelId
            const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
            const entityModel = gameModel.entityModels[entityModelId]
            
            let isActionRemoved = false
            if(interfaceActionData.isRemoved) {
              isActionRemoved = interfaceActionData.isRemoved([entityModelId], gameModel)
            }

            gameModel.effects[effectId] = {
              effectId,
              effectBehavior: EFFECT_INTERFACE_ACTION,
              interfaceActionId,
              textureId: entityModel.textureId,
              textureTint: entityModel.textureTint,
              dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
              customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
              subTitle: interfaceActionData.getSubtitle([entityModelId], gameModel),
              title: interfaceActionData.title || interfaceActionData.getTitle([entityModelId], gameModel),
              onClick: interfaceActionData.onClick([entityModelId]),
              icon: interfaceActionUIData.icon,
              subIcon: interfaceActionData.subIcon,
              entityModelId,
              isReadOnly: true,
              isRemoved: entityModel.isReadOnly || entityModel.isRemoved || isActionRemoved
            }
          })
        } else if(arg1 === 'layerId') {
          if(gameModel.layers) Object.keys(gameModel.layers).forEach((layerId) => {
            const effectId = EFFECT_DID + interfaceActionId + layerId
            const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
            gameModel.effects[effectId] = {
              effectId,
              effectBehavior: EFFECT_INTERFACE_ACTION,
              interfaceActionId,
              dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
              customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
              layerId,
              subTitle: interfaceActionData.getSubtitle([layerId], gameModel),
              title: interfaceActionData.title || interfaceActionData.getTitle([layerId], gameModel),
              onClick: interfaceActionData.onClick([layerId]),
              icon: interfaceActionUIData.icon,
              subIcon: interfaceActionData.subIcon,
              isReadOnly: true
            }
          })
        } else if(arg1 === 'brushId') {
          if(gameModel.brushes) Object.keys(gameModel.brushes).forEach((brushId) => {
            const effectId = EFFECT_DID + interfaceActionId + brushId
            const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
            const brush = gameModel.brushes[brushId]

            if(brush.layerId === NON_LAYER_BRUSH_ID || brush.layerId === CANVAS_IMAGE_LAYER_ID) return

            gameModel.effects[effectId] = {
              effectId,
              effectBehavior: EFFECT_INTERFACE_ACTION,
              brushId,
              interfaceActionId,
              layerId: brush.layerId,
              textureId: brush.textureId,
              textureTint: brush.textureTint,
              dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
              customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
              subTitle: interfaceActionData.getSubtitle([brushId], gameModel),
              title:  interfaceActionData.title || interfaceActionData.getTitle([brushId], gameModel),
              onClick: interfaceActionData.onClick([brushId]),
              icon: interfaceActionUIData.icon,
              subIcon: interfaceActionData.subIcon,
              isReadOnly: true
            }
          })
        } else if(arg1 === 'colorId') {
          if(gameModel.colors) Object.keys(gameModel.colors).forEach((colorId) => {
            const color = gameModel.colors[colorId]

            Object.keys(color).forEach((layerId) => {
              const effectId = EFFECT_DID + interfaceActionId + colorId + layerId
              if(layerId === NON_LAYER_COLOR_ID || layerId === CANVAS_IMAGE_LAYER_ID) return
              const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
              gameModel.effects[effectId] = {
                effectId,
                effectBehavior: EFFECT_INTERFACE_ACTION,
                interfaceActionId,
                colorId,
                layerId,
                textureTint: colorId,
                dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
                customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
                subTitle: interfaceActionData.getSubtitle([colorId, layerId], gameModel) ,
                title: interfaceActionData.title || interfaceActionData.getTitle([colorId, layerId], gameModel),
                onClick: interfaceActionData.onClick([colorId, layerId]),
                icon: interfaceActionUIData.icon,
                subIcon: interfaceActionData.subIcon,
                isReadOnly: true
              }
            })

          })
        } else if(arg1 === 'stageId') {
          if(gameModel.stages) {
            Object.keys(gameModel.stages).forEach((stageId) => {
              const effectId = EFFECT_DID + interfaceActionId + stageId
              const interfaceActionUIData = interfaceActionGroupData[interfaceActionData.interfaceActionGroupId]
              gameModel.effects[effectId] = {
                effectId,
                effectBehavior: EFFECT_INTERFACE_ACTION,
                interfaceActionId,
                stageId,
                dataSourceIID: DERIVED_INTERFACE_ACTION_IID,
                customSelectorCategory: interfaceActionData.customSelectorCategory || interfaceActionUIData.displayName,
                subTitle:  interfaceActionData.getSubtitle([stageId], gameModel),
                title: interfaceActionData.title || interfaceActionData.getTitle([stageId], gameModel),
                onClick: interfaceActionData.onClick([stageId]),
                icon: interfaceActionUIData.icon,
                subIcon: interfaceActionData.subIcon,
                isReadOnly: true
              }
            })
          }
        }
      })

    }
  })
}

// export function addAutogeneratedEntityModels(gameData) {
//   if(gameData.entityModels) {
//     Object.keys(gameData.entityModels).forEach((entityModelId) => {
//       const entityModel = gameData.entityModels[entityModelId]
//       if(entityModel.graphics && entityModel.entityClassIID === PLAYER_ENTITY_IID) {
//         const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
//         const powerUpEntity  = {
//           dataSourceIID: DERIVED_AUTOGENERATION_IID,
//           name: 'Player Powerup - ' + entityModel.name,
//           relationTags: {
//             [playerPowerUpEntityId]: {
//               isReadOnly: true
//             }
//           },
//           autogeneration: {
//             teleportToEffect: false,
//               playerTeleportToRelationTag: false,
//             transformIntoEffect: false,
//               playerTransformIntoRelationTag: false,
//             automaticEntityTag: false,
//             spawnOntoStageEffect: false,
//             destroyAllEffect: true,
//           },
//           entityClassIID: BASIC_ENTITY_IID,
//           entityModelId: playerPowerUpEntityId,
//           graphics: {
//             glowing: true,
//             textureId: entityModel.graphics.textureId,
//             textureTint: entityModel.graphics.textureTint
//           },
//         }

//         if(gameData.entityModels[playerPowerUpEntityId]) {
//           gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultBasicEntity), powerUpEntity, gameData.entityModels[playerPowerUpEntityId])
//         } else {
//           gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultBasicEntity), powerUpEntity)
//         }
//       }
//     })
//   }
// }

export function addDefaultsToGameModel(gameData, oldGameData) {
  if(oldGameData) {
    if(gameData.stages) {
      Object.keys(gameData.stages).forEach((stageId) => {
        const stage = gameData.stages[stageId]
        if(stage && oldGameData.stages[stageId]) {
          const entityInstances = stage.entityInstances 
          const oldObjects = oldGameData.stages[stageId].entityInstances
          if(entityInstances) Object.keys(entityInstances).forEach((id) => {
            if(!oldObjects[id]) entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
          })
        }
      })
    }

    if(gameData.entityModels) Object.keys(gameData.entityModels).forEach((id) => {
      if(!oldGameData.entityModels[id]) gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity), gameData.entityModels[id])
    })

    return
  }


  if(gameData.entityModels) {
    Object.keys(gameData.entityModels).forEach((id) => {
      if(gameData.entityModels[id].dataSourceIID === DERIVED_AUTOGENERATION_IID) {
        console.log('skipping')
        return 
      }
      gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity),  gameData.entityModels[id])
    })
  }

  if(gameData.stages) {
    Object.keys(gameData.stages).forEach((stageId) => {
      const stage = gameData.stages[stageId]
      const entityInstances = stage.entityInstances 
      if(entityInstances) Object.keys(entityInstances).forEach((id) => {
        entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
      })
    })
  }

  if(gameData.relations) {
    Object.keys(gameData.relations).forEach((relationId) => {
      gameData.relations[relationId] = mergeDeep(_.cloneDeep(defaultRelationship), gameData.relations[relationId])
    })
  }
}

// export function addImportedGamesToGameModel(gameData) {
//   // classLibrary.forEach((entityModel) => {
//   //   if(gameData.entityModels[entityModel.entityModelId]) {
//   //     gameData.entityModels[entityModel.entityModelId] = mergeDeep(_.cloneDeep(entityModel), gameData.entityModels[entityModel.entityModelId])
//   //   } else {
//   //     gameData.entityModels[entityModel.entityModelId] = _.cloneDeep(entityModel)
//   //   }
//   // })
//   gameData.relationTags = {
//     ..._.cloneDeep(initialTags),
//     ...gameData.relationTags
//   }
// }

export function enrichGameModel(gameData) {
  if(!gameData.brushes) gameData.brushes = {}
  if(!gameData.relationTags) gameData.relationTags = {}

  Object.keys(effectEditInterfaces).forEach((effectBehavior) => {
    const effectEditInterface = {...effectEditInterfaces[effectBehavior], ...effectInterfaceDatas[effectBehavior]}
    const effectName = effectEditInterface.displayName

    if(effectEditInterface.autogenerateEffect) {
      gameData.effects[effectBehavior] = {
        effectId: effectBehavior,
        effectBehavior: effectBehavior,
        dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
        isCommonlyUsed: true,
        isReadOnly: true,
        customSelectorCategory: effectEditInterface.customSelectorCategory,
      }

      if(effectEditInterface.autogenerateRelationForEvents) {
        effectEditInterface.autogenerateRelationForEvents.forEach((eventType) => {
          const rootEventId = effectBehavior + eventType
          const rootRelationId = effectBehavior + eventType

          const eventTypeInterface = eventTypeInterfaces[eventType]
          const eventName = eventShortNames[eventType]

          const targetableType = effectEditInterfaces[effectBehavior].targetableType

          const targetName = []
          if(targetableType === NO_RELATION_TAG_EFFECT_IID) {
            targetName.push('-none')
          } else if(targetableType === SINGLE_RELATION_TAG_EFFECT_IID) {
            targetName.push('-player')
            targetName.push('-entity')
          } else if(targetableType === TWO_RELATION_TAG_EFFECT_IID) {
            targetName.push('-player')
            targetName.push('-entity')
          }


          targetName.forEach((targetName) => {
            const eventId = rootEventId + targetName
            const relationId = rootRelationId + targetName

            if(eventTypeInterface.relationTagSelectType === SINGLE_RELATION_TAG_EVENT_IID) {
              gameData.relationTags[eventId] = {
                dataSourceIID: DERIVED_AUTOGENERATION_IID,
                relationTagId: eventId,
                name: effectName,
                description: `When the ${eventName} event occurs for this`,
                relationTagIID: RELATION_TAG_GENERAL_IID,
                isReadOnly: true,
                icon: effectEditInterface.icon
                // editorInterface: {
                //   requiresUnlocking: true
                // }
              }

              gameData.events[eventId] = {
                eventId: eventId,
                eventType: eventType,
                relationTagIdA: eventId,
                dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
                isReadOnly: true
              }
            } else if(eventTypeInterface.relationTagSelectType === PLAYER_AND_RELATION_TAG_EVENT_IID || eventTypeInterface.relationTagSelectType === TWO_RELATION_TAG_EVENT_IID) {
              
              gameData.relationTags[eventId] = {
                dataSourceIID: DERIVED_AUTOGENERATION_IID,
                relationTagId: eventId,
                name: getAutogeneratedTagName({effectName, eventName, targetName}),
                description: getAutogeneratedTagDescription({eventName, effectName, targetName}),
                relationTagIID: RELATION_TAG_GENERAL_IID,
                isReadOnly: true,
                icon: effectEditInterface.icon
                // editorInterface: {
                //   requiresUnlocking: true
                // }
              }

              gameData.events[eventId] = {
                eventId: eventId,
                eventType: eventType,
                relationTagIdA: PLAYER_RELATION_TAG_ID,
                relationTagIdB: eventId,
                dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
                isReadOnly: true
              }
            }
  
            gameData.relations[relationId] = {
              relationId: relationId,
              eventId,
              isReadOnly: true,
              effects: {
                [effectBehavior]: {
                  effectId: effectBehavior,
                  effectTagA: targetName === '-player',
                  effectTagB: targetName === '-entity' 
                }
              },
              effectIds: [effectBehavior],
              dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID
            }
          })


        })
      }
    }
  })

  Object.keys(gameData.cutscenes).forEach((cutsceneId) => {
    const cutscene = gameData.cutscenes[cutsceneId]
    
    gameData.effects[cutsceneId] = {
      effectId: cutsceneId,
      effectBehavior: EFFECT_CUTSCENE,
      cutsceneId,
      dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
      isReadOnly: true
    }

    const playthroughStartCutsceneId = PLAYTHROUGH_START_CUTSCENE_IVID
    if(cutsceneId === playthroughStartCutsceneId) {
      const playthroughCutscenePowerId = cutsceneId + ON_PLAYTHROUGH

      gameData.events[playthroughCutscenePowerId] = {
        eventId: playthroughCutscenePowerId,
        eventType: ON_PLAYTHROUGH,
        relationTagIdA: PLAYER_RELATION_TAG_ID,
        cutsceneId: cutsceneId,
        dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
        isReadOnly: true,
      }

      gameData.relations[playthroughCutscenePowerId] = {
        relationId: playthroughCutscenePowerId,
        eventId: playthroughCutscenePowerId,
        isReadOnly: true,
        effects: {
          [cutsceneId]: {
            effectId: cutsceneId
          }
        },
        effectIds: [cutsceneId],
        dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID
      }
    } else {
      const endGameCutsceneId = END_GAME_CUTSCENE_IVID
      if(cutsceneId === endGameCutsceneId) {
        const endGameCutscenePowerId = cutsceneId + '-endGame'
        gameData.events[endGameCutscenePowerId] = {
          eventId: endGameCutscenePowerId,
          eventType: ON_CUTSCENE_END,
          cutsceneId: cutsceneId,
          relationTagIdA: PLAYER_RELATION_TAG_ID,
          dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
          isReadOnly: true,
        }

        gameData.relations[endGameCutscenePowerId] = {
          relationId: endGameCutscenePowerId,
          eventId: endGameCutscenePowerId,
          isReadOnly: true,
          effects: {
            [EFFECT_END_GAME]: {
              effectId: EFFECT_END_GAME
            }
          },
          effectIds: [EFFECT_END_GAME],
          dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID
        }
      }

      const cutsceneEventTypes = [ON_INTERACT, ON_TOUCH_START]
      cutsceneEventTypes.forEach((eventType) => {
        generateCutsceneRelationTag({gameData, cutsceneId, eventType})
      })
    }
  })

  Object.keys(gameData.entityModels).forEach((entityModelId) => {
    const entityModel = gameData.entityModels[entityModelId]

    if(entityModel.entityClassIID === PLAYER_ENTITY_IID) {
      entityModel.relationTags[PLAYER_RELATION_TAG_ID] = {
        isReadOnly: true,
      }
    }
   
    const transformIntoEffect = entityModel.autogeneration.transformIntoEffect
    if(transformIntoEffect) {
      const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
      
      gameData.effects[playerPowerUpEntityId] = {
        effectId: playerPowerUpEntityId,
        effectBehavior: EFFECT_TRANSFORM,
        entityModelId,
        dataSourceIID: DERIVED_AUTOGENERATION_IID,
        isReadOnly: true
      }

      const playerTransformIntoRelationTag = entityModel.autogeneration.playerTransformIntoRelationTag
      if(playerTransformIntoRelationTag) {
        gameData.events[playerPowerUpEntityId] = {
          eventId: playerPowerUpEntityId,
          eventType: ON_TOUCH_START,
          relationTagIdA: PLAYER_RELATION_TAG_ID,
          relationTagIdB: playerPowerUpEntityId,
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relations[playerPowerUpEntityId] = {
          relationId: playerPowerUpEntityId,
          eventId: playerPowerUpEntityId,
          effects: {
            [playerPowerUpEntityId]: {
              effectTagA: true,
              effectId: playerPowerUpEntityId
            }
          },
          effectIds: [playerPowerUpEntityId],
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relationTags[playerPowerUpEntityId] = {
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          relationTagId: playerPowerUpEntityId,
          name: 'Transform Player into ' + entityModel.name + '',
          description: 'When the Player Touching event occurs',
          textureId: entityModel.graphics.textureId,
          textureTint: entityModel.graphics.textureTint,
          relationTagIID: RELATION_TAG_TRANSFORM_IID,
          isReadOnly: true
          // editorInterface: {
          //   requiresUnlocking: true
          // }
        }
      }

      const playerTemporaryPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)+'-temporary'
      gameData.effects[playerTemporaryPowerUpEntityId] = {
        effectId: playerTemporaryPowerUpEntityId,
        effectBehavior: EFFECT_TRANSFORM_TEMPORARY_START,
        entityModelId,
        dataSourceIID: DERIVED_AUTOGENERATION_IID,
        isReadOnly: true
      }

      if(playerTransformIntoRelationTag) {
        gameData.events[playerTemporaryPowerUpEntityId] = {
          eventId: playerTemporaryPowerUpEntityId,
          eventType: ON_TOUCH_START,
          relationTagIdA: PLAYER_RELATION_TAG_ID,
          relationTagIdB: playerTemporaryPowerUpEntityId,
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relations[playerTemporaryPowerUpEntityId] = {
          relationId: playerTemporaryPowerUpEntityId,
          eventId: playerTemporaryPowerUpEntityId,
          effects: {
            [playerTemporaryPowerUpEntityId]: {
              effectTagA: true,
              effectId: playerTemporaryPowerUpEntityId
            }
          },
          effectIds: [playerTemporaryPowerUpEntityId],
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relationTags[playerTemporaryPowerUpEntityId] = {
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          relationTagId: playerTemporaryPowerUpEntityId,
          name: 'Transform Player ( Temporarily ) into ' + entityModel.name + '',
          description: 'When the Player Touching event occurs',
          textureId: entityModel.graphics.textureId,
          textureTint: entityModel.graphics.textureTint,
          relationTagIID: RELATION_TAG_TRANSFORM_IID,
          isReadOnly: true
          // editorInterface: {
          //   requiresUnlocking: true
          // }
        }
      }
    }

    const teleportToEffect = entityModel.autogeneration.teleportToEffect
    if(teleportToEffect) {
     
      const teleportEntityId = 'teleport-'+entityModelId
      gameData.effects[teleportEntityId] = {
        effectId: teleportEntityId,
        effectBehavior: EFFECT_TELEPORT,
        zoneEntityModelId: entityModelId,
        dataSourceIID: DERIVED_AUTOGENERATION_IID,
        isReadOnly: true

      }

      const playerTeleportToRelationTag = entityModel.autogeneration.playerTeleportToRelationTag
      if(playerTeleportToRelationTag) {
        gameData.events[teleportEntityId] = {
          eventId: teleportEntityId,
          eventType: ON_INTERACT,
          relationTagIdA: PLAYER_RELATION_TAG_ID,
          relationTagIdB: teleportEntityId,
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relations[teleportEntityId] = {
          relationId: teleportEntityId,
          eventId: teleportEntityId,
          effects: {
            [teleportEntityId]: {
              effectTagA: true,
              effectId: teleportEntityId
            }
          },
          effectIds: [teleportEntityId],
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }

        gameData.relationTags[teleportEntityId] = {
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          relationTagId: teleportEntityId,
          name: 'Teleport Player to ' + entityModel.name + '',
          description: 'When the Player Interacts event occurs',
          icon: effectInterfaceDatas[EFFECT_TELEPORT].icon,
          iconColor: entityModel.graphics.textureTint,
          relationTagIID: RELATION_TAG_TELEPORT_IID,
          isReadOnly: true
        }
      }
    }

    if(entityModel.spawnZoneEntityModelIds) {
      entityModel.spawnZoneEntityModelIds.forEach((zoneEntityModelId) => {
        const spawnEntityModelId = 'spawn-'+entityModelId+'-'+zoneEntityModelId
        gameData.effects[spawnEntityModelId] = {
          effectId: spawnEntityModelId,
          effectBehavior: EFFECT_SPAWN,
          zoneEntityModelId,
          spawnEntityModelId: entityModelId,
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }
      })
    }

    const spawnOntoStageEffect = entityModel.autogeneration.spawnOntoStageEffect
    const initialStageZoneEntityId = STAGE_ZONE_ENTITY_IVID
    if(spawnOntoStageEffect) {
      const spawnEntityModelId = 'spawn-'+entityModelId
      gameData.effects[spawnEntityModelId] = {
        effectId: spawnEntityModelId,
        effectBehavior: EFFECT_SPAWN,
        zoneEntityModelId: initialStageZoneEntityId,
        spawnEntityModelId: entityModelId,
        isReadOnly: true,
        dataSourceIID: DERIVED_AUTOGENERATION_IID,
      }
    }

    if(entityModel.graphics.textureId) {
      gameData.brushes[BRUSH_DID + entityModel.entityModelId] = {
        layerId: NON_LAYER_BRUSH_ID,
        textureId: entityModel.graphics.textureId,
        textureTint: entityModel.graphics.textureTint,
        dataSourceIID: DERIVED_AUTOGENERATION_IID,
        isReadOnly: true
      }
    }

    if(entityModel.autogeneration.automaticEntityTag) {
      entityModel.relationTags[entityModelId] = {
        isReadOnly: true
      }
      gameData.relationTags[entityModel.entityModelId] = {
        relationTagIID: RELATION_TAG_ENTITY_IID,
        dataSourceIID: DERIVED_ENTITY_MODEL_IID,
        textureId: entityModel.graphics.textureId,
        entityClassIID: entityModel.entityClassIID,
        textureTint: entityModel.graphics.textureTint,
        relationTagId: entityModel.entityModelId,
        importedStageIds: entityModel.importedStageIds,
        isRemoved: entityModel.isRemoved,
        name: entityModel.name,
        isReadOnly: true
      }
    }
  })
  
  Object.keys(gameData.relationTags).forEach((relationTagId) => {
    const relationTag = gameData.relationTags[relationTagId]
    const relationTagEntity  = gameData.entityModels[relationTagId]

    if(relationTag.relationTagIID === RELATION_TAG_ENTITY_IID || relationTag.relationTagIID === RELATION_TAG_GENERAL_IID) {
      if(relationTagEntity?.autogeneration.destroyAllEffect) {
        const destroyRelationTagId = 'destroy-'+relationTagId
        gameData.effects[destroyRelationTagId] = {
          effectId: destroyRelationTagId,
          effectBehavior: EFFECT_DESTROY,
          remoteEffectedRelationTagIds: [relationTagId],
          dataSourceIID: DERIVED_AUTOGENERATION_IID,
          isReadOnly: true
        }
      }
    }
  })

  Object.keys(gameData.stages).forEach((stageId) => {
    gameData.effects[stageId] = {
      effectId: stageId,
      effectBehavior: EFFECT_SWITCH_STAGE,
      stageId,
      dataSourceIID: DERIVED_DEFAULT_SYSTEM_IID,
      isReadOnly: true
    }
  })

  Object.keys(gameData.relationTags).forEach((id) => {
    gameData.relationTags[id] = mergeDeep(_.cloneDeep(defaultRelationTag),  gameData.relationTags[id])
  })
}

export function cleanGameModel(gameData) {
  Object.keys(gameData.stages).forEach((key) => {
    const stage = gameData.stages[key]
    if (gameData.stages[key] === null || gameData.stages[key] === undefined) {
      console.log('deleting stage', key)
      delete gameData.stages[key];
    }

    // the default stage doesnt start with entityInstance because its virtual so gotta check
    if(stage.entityInstances) Object.keys(stage.entityInstances).forEach(key => {
      if (stage.entityInstances[key] === null || stage.entityInstances[key] === undefined) {
        console.log('deleting object', key)
        delete stage.entityInstances[key];
      }
    });
  })

  Object.keys(gameData.cutscenes).forEach(key => {
    if (gameData.cutscenes[key] === null || gameData.cutscenes[key] === undefined) {
      console.log('deleting cutscene', key)
      delete gameData.cutscenes[key];
    }
  });

  Object.keys(gameData.entityModels).forEach(key => {
    if (gameData.entityModels[key] === null || gameData.entityModels[key] === undefined) {
      console.log('deleting class', key)
      delete gameData.entityModels[key];
      return
    }
  });

  Object.keys(gameData.relations).forEach(key => {
    if (gameData.relations[key] === null || gameData.relations[key] === undefined) {
      console.log('deleting relation', key)
      delete gameData.relations[key];
    }
  });

  Object.keys(gameData.collisions).forEach(key => {
    if (gameData.collisions[key] === null || gameData.collisions[key] === undefined) {
      console.log('deleting collision', key)
      delete gameData.collisions[key];
    }
  });


  Object.keys(gameData.effects).forEach(key => {
    if (gameData.effects[key] === null || gameData.effects[key] === undefined) {
      console.log('deleting effect', key)
      delete gameData.effects[key];
    }
  });

  Object.keys(gameData.events).forEach(key => {
    if (gameData.events[key] === null || gameData.events[key] === undefined) {
      console.log('deleting event', key)
      delete gameData.events[key];
    }
  });

  
}
