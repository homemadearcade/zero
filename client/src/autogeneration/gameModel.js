import _ from "lodash"
import { DATA_SOURCE_AUTOGENERATED_IID, DATA_SOURCE_ENTITY_MODEL_IID, POWERUP_ENTITY_IID, RELATION_TAG_ENTITY_IID, RELATION_TAG_CUTSCENE_IID, RELATION_TAG_DIALOGUE_IID, RELATION_TAG_GENERAL_IID, RELATION_TAG_TELEPORT_IID, RELATION_TAG_TRANSFORM_IID, PLAYER_ENTITY_IID, DATA_SOURCE_IMPORTED_GAME_MODEL, DATA_SOURCE_SYSTEM_IID } from "../constants/interfaceIds"
import { defaultEntity, defaultEntityInstance, defaultPowerupEntity, defaultStage, defaultRelationTag,
  effectBehaviorInterfaces, EFFECT_CUTSCENE, EFFECT_DESTROY, EFFECT_SPAWN, EFFECT_TELEPORT, EFFECT_TRANSFORM, 
  initialTags, ON_INTERACT, playerRelationTagId, 
 } from "../game/constants"
 import { classLibrary } from "../game/classLibrary"
import { BRUSH_DID, EFFECT_SWITCH_STAGE, ON_TOUCH_START } from "../game/constants/core"
import { NON_LAYER_BRUSH_ID } from "../game/constants/core"
import { initialStageZoneEntityId } from "../game/constants/core"
import { mergeDeep } from "../utils/utils"
import { getPlayerPowerupEntityId } from "./utils"

export function addAutogeneratedEntityModels(gameData) {
  if(gameData.entityModels) {
    Object.keys(gameData.entityModels).forEach((entityModelId) => {
      const entityModel = gameData.entityModels[entityModelId]
      if(entityModel.entityInterfaceId === PLAYER_ENTITY_IID) {
        const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
        const powerUpEntity  = {
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          name: 'Touch Transform - ' + entityModel.name,
          relationTags: {
            [playerPowerUpEntityId]: {
              isReadOnly: true
            }
          },
          autogeneration: {
            automaticEntityTag: false,
          },
          entityInterfaceId: POWERUP_ENTITY_IID,
          entityModelId: playerPowerUpEntityId,
          graphics: {
            textureId: entityModel.graphics.textureId,
            textureTint: entityModel.graphics.textureTint
          },
        }

        if(gameData.entityModels[playerPowerUpEntityId]) {
          gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultPowerupEntity), powerUpEntity, gameData.entityModels[playerPowerUpEntityId])
        } else {
          gameData.entityModels[playerPowerUpEntityId] = mergeDeep(_.cloneDeep(defaultEntity), _.cloneDeep(defaultPowerupEntity), powerUpEntity)
        }
      }
    })
  }
}

export function addDefaultsToGameModel(gameData, oldGameData) {
  if(oldGameData) {
    if(gameData.stages) {
      Object.keys(gameData.stages).forEach((stageId) => {
        const stage = gameData.stages[stageId]
        if(stage && oldGameData.stages[stageId]) {
          const entityInstances = stage.entityInstances 
          const oldObjects = oldGameData.stages[stageId].entityInstances
          if(entityInstances) Object.keys(entityInstances).forEach((id) => {
            if(!oldObjects[id]) entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
          })
        }
      })
    }

    if(gameData.entityModels) Object.keys(gameData.entityModels).forEach((id) => {
      if(!oldGameData.entityModels[id]) gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity), gameData.entityModels[id])
    })

    return 
  }

  if(gameData.entityModels) {
    Object.keys(gameData.entityModels).forEach((id) => {
      if(gameData.entityModels[id].dataSourceId === DATA_SOURCE_AUTOGENERATED_IID) {
        console.log('skipping')
        return 
      }
      gameData.entityModels[id] = mergeDeep(_.cloneDeep(defaultEntity),  gameData.entityModels[id])
    })
  }

  if(gameData.stages) {
    Object.keys(gameData.stages).forEach((stageId) => {
      const stage = gameData.stages[stageId]
      gameData.stages[stageId] = mergeDeep(_.cloneDeep(defaultStage), gameData.stages[stageId])
      const entityInstances = stage.entityInstances 
      if(entityInstances) Object.keys(entityInstances).forEach((id) => {
        entityInstances[id] = mergeDeep(_.cloneDeep(defaultEntityInstance), entityInstances[id])
      })
    })
  }
}

export function addImportedGamesToGameModel(gameData) {
  classLibrary.forEach((entityModel) => {
    if(gameData.entityModels[entityModel.entityModelId]) {
      gameData.entityModels[entityModel.entityModelId] = mergeDeep(_.cloneDeep(entityModel), gameData.entityModels[entityModel.entityModelId])
    } else {
      gameData.entityModels[entityModel.entityModelId] = _.cloneDeep(entityModel)
    }
  })

  gameData.importedArcadeGames.forEach((importedGame) => {
    if(importedGame.entityModels) {
      Object.keys(importedGame.entityModels).forEach((entityModelId) => {
        const importedEntityModel = importedGame.entityModels[entityModelId]
        importedEntityModel.isImported = false
        if(gameData.entityModels[entityModelId]) {
          gameData.entityModels[entityModelId] = mergeDeep(_.cloneDeep(importedEntityModel), gameData.entityModels[entityModelId])
        } else {
          gameData.entityModels[entityModelId] = _.cloneDeep(importedEntityModel)
        }
        gameData.entityModels[entityModelId].dataSourceId = DATA_SOURCE_IMPORTED_GAME_MODEL
      })
    }

    if(importedGame.relations) {
      Object.keys(importedGame.relations).forEach((relationId) => {
        const importedRelation = importedGame.relations[relationId]
        gameData.relations[relationId] = _.cloneDeep(importedRelation)
        gameData.relations[relationId].dataSourceId = DATA_SOURCE_IMPORTED_GAME_MODEL
        gameData.relations[relationId].isReadOnly = true
      })
    }

    if(importedGame.effects) {
      Object.keys(importedGame.effects).forEach((effectId) => {
        const importedEffect = importedGame.effects[effectId]
        gameData.effects[effectId] = _.cloneDeep(importedEffect)
        gameData.effects[effectId].dataSourceId = DATA_SOURCE_IMPORTED_GAME_MODEL
        gameData.effects[effectId].isReadOnly = true
      })
    }

    if(importedGame.events) {
      Object.keys(importedGame.events).forEach((effectId) => {
        const importedEffect = importedGame.events[effectId]
        gameData.events[effectId] = _.cloneDeep(importedEffect)
        gameData.events[effectId].dataSourceId = DATA_SOURCE_IMPORTED_GAME_MODEL
        gameData.events[effectId].isReadOnly = true
      })
    }

    if(importedGame.relationTags) {
      Object.keys(importedGame.relationTags).forEach((relationTagId) => {
        const importedEffect = importedGame.relationTags[relationTagId]
        gameData.relationTags[relationTagId] = _.cloneDeep(importedEffect)
        gameData.relationTags[relationTagId].dataSourceId = DATA_SOURCE_IMPORTED_GAME_MODEL
        gameData.relationTags[relationTagId].isReadOnly = true
      })
    }
  })
  

  gameData.relationTags = {
    ..._.cloneDeep(initialTags),
    ...gameData.relationTags
  }

}

export function enrichGameModel(gameData) {
  if(!gameData.brushes) gameData.brushes = {}
  if(!gameData.relationTags) gameData.relationTags = {}

  Object.keys(effectBehaviorInterfaces).forEach((effectBehavior) => {
    const effectBehaviorInterface = effectBehaviorInterfaces[effectBehavior]
    if(effectBehaviorInterface.isStandalone) {
      gameData.effects[effectBehavior] = {
        effectId: effectBehavior,
        effectBehavior: effectBehavior,
        dataSourceId: DATA_SOURCE_SYSTEM_IID,
        customSelectorCategory: '_General',
        isReadOnly: true
      }
    }
  })

  Object.keys(gameData.cutscenes).forEach((cutsceneId) => {
    const cutscene = gameData.cutscenes[cutsceneId]
    
    gameData.effects[cutsceneId] = {
      effectId: cutsceneId,
      effectBehavior: EFFECT_CUTSCENE,
      cutsceneId,
      dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
      isReadOnly: true
    }

    gameData.relationTags[cutsceneId] = {
      dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
      relationTagId: cutsceneId,
      name: 'Interact to play "' + cutscene.name + '"',
      isReadOnly: true,
      relationTagInterfaceId: cutscene.inDialogueMenu ? RELATION_TAG_DIALOGUE_IID : RELATION_TAG_CUTSCENE_IID
    }

    gameData.events[cutsceneId] = {
      eventId: cutsceneId,
      eventType: ON_INTERACT,
      relationTagIdA: playerRelationTagId,
      relationTagIdB: cutsceneId,
      dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
      isReadOnly: true,
    }

    gameData.relations[cutsceneId] = {
      relationId: cutsceneId,
      eventId: cutsceneId,
      isReadOnly: true,
      effects: {
        [cutsceneId]: {
          effectId: cutsceneId
        }
      },
      effectIds: [cutsceneId],
      dataSourceId: DATA_SOURCE_AUTOGENERATED_IID
    }
  })

  Object.keys(gameData.entityModels).forEach((entityModelId) => {
    const entityModel = gameData.entityModels[entityModelId]

    entityModel.relationTags[entityModelId] = {
      isReadOnly: true
    }
    if(entityModel.entityInterfaceId === PLAYER_ENTITY_IID) {
      entityModel.relationTags[playerRelationTagId] = {
        isReadOnly: true,
      }
    }
   
    const transformIntoEffect = entityModel.autogeneration.transformIntoEffect
    if(transformIntoEffect) {
      const playerPowerUpEntityId = getPlayerPowerupEntityId(entityModelId)
      
      gameData.effects[playerPowerUpEntityId] = {
        effectId: playerPowerUpEntityId,
        effectBehavior: EFFECT_TRANSFORM,
        entityModelId,
        dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
        isReadOnly: true
      }

      const playerTransformIntoRelationTag = entityModel.autogeneration.playerTransformIntoRelationTag
      if(playerTransformIntoRelationTag) {
        gameData.events[playerPowerUpEntityId] = {
          eventId: playerPowerUpEntityId,
          eventType: ON_TOUCH_START,
          relationTagIdA: playerRelationTagId,
          relationTagIdB: playerPowerUpEntityId,
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          isReadOnly: true
        }

        gameData.relations[playerPowerUpEntityId] = {
          relationId: playerPowerUpEntityId,
          eventId: playerPowerUpEntityId,
          effects: {
            [playerPowerUpEntityId]: {
              effectTagA: true,
              effectId: playerPowerUpEntityId
            }
          },
          effectIds: [playerPowerUpEntityId],
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          isReadOnly: true
        }

        gameData.relationTags[playerPowerUpEntityId] = {
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          relationTagId: playerPowerUpEntityId,
          name: 'Touch to transform Player into ' + entityModel.name + '',
          relationTagInterfaceId: RELATION_TAG_TRANSFORM_IID,
          isReadOnly: true
          // editorInterface: {
          //   requiresUnlocking: true
          // }
        }
      }
    }

    const teleportToEffect = entityModel.autogeneration.teleportToEffect
    if(teleportToEffect) {
     
      const teleportEntityId = 'teleport-'+entityModelId
      gameData.effects[teleportEntityId] = {
        effectId: teleportEntityId,
        effectBehavior: EFFECT_TELEPORT,
        zoneEntityModelId: entityModelId,
        dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
        isReadOnly: true

      }

      const playerTeleportToRelationTag = entityModel.autogeneration.playerTeleportToRelationTag
      if(playerTeleportToRelationTag) {
        gameData.events[teleportEntityId] = {
          eventId: teleportEntityId,
          eventType: ON_INTERACT,
          relationTagIdA: playerRelationTagId,
          relationTagIdB: teleportEntityId,
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          isReadOnly: true
        }

        gameData.relations[teleportEntityId] = {
          relationId: teleportEntityId,
          eventId: teleportEntityId,
          effects: {
            [teleportEntityId]: {
              effectTagA: true,
              effectId: teleportEntityId
            }
          },
          effectIds: [teleportEntityId],
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          isReadOnly: true

        }

        gameData.relationTags[teleportEntityId] = {
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          relationTagId: teleportEntityId,
          name: 'Interact to teleport Player to ' + entityModel.name + '',
          relationTagInterfaceId: RELATION_TAG_TELEPORT_IID,
          isReadOnly: true
        }
      }
    }

    const spawnOntoStageEffect = entityModel.autogeneration.spawnOntoStageEffect
    if(spawnOntoStageEffect) {
      const spawnEntityModelId = 'spawn-'+entityModelId
      gameData.effects[spawnEntityModelId] = {
        effectId: spawnEntityModelId,
        effectBehavior: EFFECT_SPAWN,
        zoneEntityModelId: initialStageZoneEntityId,
        spawnEntityModelId: entityModelId,
        isReadOnly: true,
        dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
      }
    }

    if(entityModel.graphics.textureId) {
      gameData.brushes[BRUSH_DID + entityModel.entityModelId] = {
        layerId: NON_LAYER_BRUSH_ID,
        textureId: entityModel.graphics.textureId,
        textureTint: entityModel.graphics.textureTint,
        dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
        isReadOnly: true
      }
    }

    if(entityModel.autogeneration.automaticEntityTag) {
      gameData.relationTags[entityModel.entityModelId] = {
        relationTagInterfaceId: RELATION_TAG_ENTITY_IID,
        dataSourceId: DATA_SOURCE_ENTITY_MODEL_IID,
        textureId: entityModel.graphics.textureId,
        entityInterfaceId: entityModel.entityInterfaceId,
        textureTint: entityModel.graphics.textureTint,
        relationTagId: entityModel.entityModelId,
        isImported: entityModel.isImported,
        isRemoved: entityModel.isRemoved,
        name: entityModel.name,
        isReadOnly: true
      }
    }
  })
  
  Object.keys(gameData.relationTags).forEach((relationTagId) => {
    const relationTag = gameData.relationTags[relationTagId]
    const relationTagEntity  = gameData.entityModels[relationTagId]

    if(relationTag.relationTagInterfaceId === RELATION_TAG_ENTITY_IID || relationTag.relationTagInterfaceId === RELATION_TAG_GENERAL_IID) {
      if(relationTagEntity?.autogeneration.destroyAllEffect) {
        const destroyRelationTagId = 'destroy-'+relationTagId
        gameData.effects[destroyRelationTagId] = {
          effectId: destroyRelationTagId,
          effectBehavior: EFFECT_DESTROY,
          remoteEffectedRelationTagIds: [relationTagId],
          dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
          isReadOnly: true
        }
      }
    }
  })

  Object.keys(gameData.stages).forEach((stageId) => {
    gameData.effects[stageId] = {
      effectId: stageId,
      effectBehavior: EFFECT_SWITCH_STAGE,
      stageId,
      dataSourceId: DATA_SOURCE_AUTOGENERATED_IID,
      isReadOnly: true
    }
  })

  Object.keys(gameData.relationTags).forEach((id) => {
    gameData.relationTags[id] = mergeDeep(_.cloneDeep(defaultRelationTag),  gameData.relationTags[id])
  })
}

export function cleanGameModel(gameData) {
  Object.keys(gameData.stages).forEach((key) => {
    const stage = gameData.stages[key]
    if (gameData.stages[key] === null || gameData.stages[key] === undefined) {
      console.log('deleting stage', key)
      delete gameData.stages[key];
    }

    // the default stage doesnt start with entityInstance because its virtual so gotta check
    if(stage.entityInstances) Object.keys(stage.entityInstances).forEach(key => {
      if (stage.entityInstances[key] === null || stage.entityInstances[key] === undefined) {
        console.log('deleting object', key)
        delete stage.entityInstances[key];
      }
    });
  })

  Object.keys(gameData.cutscenes).forEach(key => {
    if (gameData.cutscenes[key] === null || gameData.cutscenes[key] === undefined) {
      console.log('deleting cutscene', key)
      delete gameData.cutscenes[key];
    }
  });

  Object.keys(gameData.entityModels).forEach(key => {
    if (gameData.entityModels[key] === null || gameData.entityModels[key] === undefined) {
      console.log('deleting class', key)
      delete gameData.entityModels[key];
      return
    }
  });

  Object.keys(gameData.relations).forEach(key => {
    if (gameData.relations[key] === null || gameData.relations[key] === undefined) {
      console.log('deleting relation', key)
      delete gameData.relations[key];
    }
  });

  Object.keys(gameData.collisions).forEach(key => {
    if (gameData.collisions[key] === null || gameData.collisions[key] === undefined) {
      console.log('deleting collision', key)
      delete gameData.collisions[key];
    }
  });


  Object.keys(gameData.effects).forEach(key => {
    if (gameData.effects[key] === null || gameData.effects[key] === undefined) {
      console.log('deleting effect', key)
      delete gameData.effects[key];
    }
  });

  Object.keys(gameData.events).forEach(key => {
    if (gameData.events[key] === null || gameData.events[key] === undefined) {
      console.log('deleting event', key)
      delete gameData.events[key];
    }
  });

  
}
