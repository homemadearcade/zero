/* eslint-disable react-hooks/exhaustive-deps */
import React, { useEffect } from 'react';
import { compose } from 'redux';
import { connect } from 'react-redux';
import './EditClassModal.scss';
import CobrowsingModal from '../../cobrowsing/CobrowsingModal/CobrowsingModal';
import { mapCobrowsingState } from '../../../utils/cobrowsingUtils';
import ClassNameForm from '../ClassNameForm/ClassNameForm';
import { editGameModel } from '../../../store/actions/gameModelActions';
import Button from '../../../ui/Button/Button';
import ClassMemberTitle from '../ClassMemberTitle/ClassMemberTitle';
import { closeEditClassModal, updateBoundaryRelation, updateCreateClass } from '../../../store/actions/gameFormEditorActions';
import SelectClassInterfaceCategory from '../../ui/SelectClassInterfaceCategory/SelectClassInterfaceCategory';
import Unlockable from '../../cobrowsing/Unlockable/Unlockable';
import { CHANGE_CLASS_TYPE_IID, CLASS_TAGS_IID } from '../../../constants/interfaceIds';
import SelectTag from '../../ui/SelectTag/SelectTag';
import SelectBoundaryEffect from '../../ui/SelectBoundaryEffect/SelectBoundaryEffect';
import { classTypeToDisplayName, classTypeToPrefix, OBJECT_CLASS_ID_PREFIX } from '../../constants';
import { generateUniqueId } from '../../../utils';

const EditClassModal = ({ updateCreateClass, closeEditClassModal, editGameModel, gameFormEditor: { entityClass }, gameModel: { gameModel } }) => {
  function handleClose() {
    closeEditClassModal()
  }

  useEffect(() => {
    if(!entityClass.entityClassId) {
      updateCreateClass({ entityClassId: OBJECT_CLASS_ID_PREFIX+classTypeToPrefix[entityClass.classInterfaceCategory]+generateUniqueId(), isNew: true })
    }
  }, [])

  if(!gameModel.entityClasses[entityClass.entityClassId]) return 

  function handleSubmit() {
    editGameModel({
      entityClasses: {
        [entityClass.entityClassId] : {
          name: entityClass.name,
          tags: entityClass.tags,
          classInterfaceCategory: entityClass.classInterfaceCategory,
          boundaryRelation: entityClass.boundaryRelation
        }
      }
    })
    handleClose()
  }

  return <CobrowsingModal open onClose={handleClose}>
    <ClassMemberTitle 
      entityClassId={entityClass.entityClassId} 
      title={<>
          {entityClass.isNew ? 'New ' : ''} {classTypeToDisplayName[entityClass.classInterfaceCategory]}
        </>
      }></ClassMemberTitle>
      <div className="EditClassModal">
      <ClassNameForm
        initialName={entityClass.name}
      />
      <Unlockable interfaceId={CHANGE_CLASS_TYPE_IID}>
        <SelectClassInterfaceCategory formLabel="Type" value={entityClass.classInterfaceCategory ? [entityClass.classInterfaceCategory]: []} onChange={(event, classInterfaceCategory) => {
          updateCreateClass({
            classInterfaceCategory: classInterfaceCategory[classInterfaceCategory.length-1]
          })
        }}/>
      </Unlockable>
      <Unlockable interfaceId={CLASS_TAGS_IID}>
        <SelectTag hideClassTags hideAutoapplied formLabel="Tags" value={entityClass.tags ? Object.keys(entityClass.tags).filter((tagId) => {
          return !!entityClass.tags[tagId]
        }) : []} onChange={(event, tags) => {

          const currentTags = Object.keys(entityClass.tags).filter((tagId) => !!entityClass.tags[tagId]).reduce((prev, tagId) => {
            const tag = entityClass.tags[tagId]
            // this purely helps with the UI so that it doesnt APPEAR delated at the end.
            // these tags will always come back through the game model update event
            if(tag.isAutogenerated) {
              prev[tagId] = {
                isAutogenerated: true
              }
            } else {
              prev[tagId] = null
            }
            return prev
          }, {})

          const newTags = tags.reduce((prev, tagId) => {
              prev[tagId] = {}
              return prev
          }, currentTags)

          updateCreateClass({
            tags: newTags
          })
        }}/>
      </Unlockable>
      <SelectBoundaryEffect
        entityClassId={entityClass.entityClassId}
        formLabel={`What happens when touching the world boundary?`}
        value={entityClass.boundaryRelation ? [entityClass.boundaryRelation] : []}
        onChange={(event, BoundaryRelations) => {
          const boundaryRelation = BoundaryRelations[BoundaryRelations.length-1]
          updateCreateClass({ boundaryRelation })
      }}/>
      <Button disabled={entityClass.error} type="submit" onClick={handleSubmit}>Save</Button>
    </div>
  </CobrowsingModal>
}

const mapStateToProps = (state) => mapCobrowsingState(state, {
  gameModel: state.gameModel,
  gameFormEditor: state.gameFormEditor
})

export default compose(
  connect(mapStateToProps, { closeEditClassModal, editGameModel, updateCreateClass }),
)(EditClassModal);
